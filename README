# Product Management REST API

A robust, production-ready Spring Boot application that provides comprehensive RESTful APIs for product management with enterprise-grade features including full CRUD operations, input validation, centralized exception handling, and persistent data storage.

## Overview

This project implements a scalable product management system with a clean, layered architecture that separates concerns across controller, service, repository, and data access layers. The application is built with Spring Boot 3.x, leverages Spring Data JPA for ORM, and uses MariaDB as the primary data store. Containerization support with Docker and Docker Compose enables seamless deployment across environments.

## Technology Stack

| Component | Version |
|-----------|---------|
| Java | 17 |
| Spring Boot | 3.x |
| Spring Framework | 6.x |
| Spring Data JPA | Latest |
| Hibernate ORM | Latest |
| MariaDB | 10.6+ |
| Apache Maven | 3.8+ |
| Lombok | 1.18+ |
| Jakarta Validation | 3.x |
| Docker | Latest |
| Docker Compose | Latest |

## Project Structure

```
productManagement/
├── pom.xml
├── README.md
├── LICENSE
├── HELP.md
├── Dockerfile
├── docker-compose.yml
└── src/
    ├── main/
    │   ├── java/com/Management/productManagement/
    │   │   ├── ProductManagementApplication.java          # Entry point
    │   │   ├── controller/
    │   │   │   └── ProductController.java               # REST endpoints
    │   │   ├── service/
    │   │   │   ├── ProductService.java                  # Service interface
    │   │   │   └── ProductServiceImpl.java               # Service implementation
    │   │   ├── repository/
    │   │   │   └── ProductRepository.java               # Data access
    │   │   ├── dto/
    │   │   │   ├── ProductDTO.java                      # Request DTO
    │   │   │   └── ProductResponseDTO.java              # Response DTO
    │   │   ├── entity/
    │   │   │   └── Product.java                         # JPA entity
    │   │   ├── exception/
    │   │   │   ├── GlobalExceptionHandler.java         # Centralized exception handling
    │   │   │   ├── ErrorDetails.java                   # Error response model
    │   │   │   └── ResourceNotFoundException.java      # Custom exception
    │   │   └── helperModule/
    │   │       └── ProductResponseDTOHelper.java       # DTO conversion utility
    │   └── resources/
    │       ├── application.properties                  # Configuration
    │       └── data.sql                               # Sample data
    └── test/
        └── [Test classes]
```

## Architecture

The application follows a **layered architectural pattern** with clear separation of concerns:

```
┌─────────────────────────────────────┐
│   Client Layer                      │
│  (Postman / Browser / Frontend)    │
└────────────────┬────────────────────┘
                 │
┌─────────────────▼────────────────────┐
│   Controller Layer                  │
│  (HTTP Request Handling)            │
└────────────────┬────────────────────┘
                 │
┌─────────────────▼────────────────────┐
│   Service Layer                     │
│  (Business Logic & Transactions)    │
└────────────────┬────────────────────┘
                 │
┌─────────────────▼────────────────────┐
│   Repository Layer                  │
│  (Data Access & Persistence)        │
└────────────────┬────────────────────┘
                 │
┌─────────────────▼────────────────────┐
│   MariaDB Database                  │
│  (Persistent Storage)               │
└─────────────────────────────────────┘
```

## Containerization with Docker

### Dockerfile

The application uses a multi-stage build process for optimized production images:

**Stage 1: Build**
- Uses Maven 3.9.6 with Eclipse Temurin JDK 17
- Downloads dependencies with `mvn dependency:go-offline`
- Compiles source code and packages as JAR

**Stage 2: Run**
- Uses Eclipse Temurin JRE 17 (lightweight runtime)
- Copies compiled JAR from build stage
- Exposes port 8080
- Sets entrypoint to run the application

### Docker Compose Setup

The `docker-compose.yml` orchestrates two services:

**MariaDB Service (`db`)**
- Image: mariadb:10.6
- Root password: root
- Database: product_db
- Persistent volume: mariadb_data
- Health check: MySQL ping every 10 seconds with 5 retries

**Application Service (`app`)**
- Image: product-management (built from Dockerfile)
- Port mapping: 8083:8083 (host:container)
- Depends on: MariaDB service (waits for healthy status)
- Environment variables configured for database connectivity

## API Endpoints

### Health Check
- **Endpoint:** `GET /api/products/health`
- **Description:** Verify API availability
- **Response:** Status OK

### Product CRUD Operations

#### Create Product
```http
POST /api/products
Content-Type: application/json

{
  "name": "Mechanical RGB Keyboard",
  "description": "High-performance mechanical keyboard with RGB lighting",
  "price": 99.99,
  "quantity": 10,
  "productCode": "ELC-777"
}
```
**Response:** `201 Created`

#### Retrieve All Products
```http
GET /api/products
```
**Response:** `200 OK` with array of products

#### Retrieve Product by ID
```http
GET /api/products/{id}
```
**Response:** `200 OK` with product details

#### Update Product (Full Update)
```http
PUT /api/products/{id}
Content-Type: application/json

{
  "name": "Updated Product Name",
  "description": "Updated description",
  "price": 129.99,
  "quantity": 20,
  "productCode": "ELC-888"
}
```
**Response:** `200 OK`

#### Update Product Quantity (Partial Update)
```http
PATCH /api/products/{id}/quantity
Content-Type: application/json

{
  "quantity": 50
}
```
**Response:** `200 OK`

#### Delete Product
```http
DELETE /api/products/{id}
```
**Response:** `204 No Content`

### Search & Filter Operations

#### Search Products by Keyword
```http
GET /api/products/search?keyword=keyboard
```
**Response:** `200 OK` with matching products

#### Filter Products by Price Range
```http
GET /api/products/price-range?minPrice=50&maxPrice=150
```
**Response:** `200 OK` with products within price range

## Key Features

### Transaction Management
All database operations are managed through the `@Transactional` annotation at the service layer, ensuring:
- **Atomicity:** All database operations succeed or fail as a single unit
- **Consistency:** Database remains in a valid state
- **Automatic Rollback:** Any failure triggers automatic transaction rollback
- **Data Integrity:** No partial updates occur

### Exception Handling
Centralized exception handling using `@ControllerAdvice` provides:
- Consistent error response format across all endpoints
- Proper HTTP status codes (400, 404, 500, etc.)
- Custom exception types for specific error scenarios
- Detailed error messages for debugging

### Input Validation
Jakarta Validation annotations ensure data integrity at the application level:
- Invalid requests return `400 Bad Request`
- Validation occurs before database interaction
- Clear error messages for validation failures

### Docker & Container Support
- Multi-stage Docker build for optimized image sizes
- Docker Compose for automated multi-container orchestration
- Health checks for database availability
- Persistent volume management for data persistence
- Environment-based configuration management

## Core Annotations Reference

### Controller Layer
| Annotation | Purpose |
|-----------|---------|
| `@RestController` | Marks class as REST endpoint handler |
| `@RequestMapping` | Maps base URL path to controller |
| `@GetMapping` | Handles HTTP GET requests |
| `@PostMapping` | Handles HTTP POST requests |
| `@PutMapping` | Handles HTTP PUT requests |
| `@PatchMapping` | Handles HTTP PATCH requests |
| `@DeleteMapping` | Handles HTTP DELETE requests |
| `@PathVariable` | Extracts values from URL path |
| `@RequestParam` | Extracts query parameters |
| `@RequestBody` | Binds JSON request body to object |
| `@CrossOrigin` | Enables CORS for frontend access |
| `ResponseEntity` | Customizes HTTP response (status, headers, body) |

### Service Layer
| Annotation | Purpose |
|-----------|---------|
| `@Service` | Marks class as service (business logic layer) |
| `@Transactional` | Manages database transaction lifecycle |
| `@Override` | Indicates method overrides parent implementation |

### Repository Layer
| Annotation | Purpose |
|-----------|---------|
| `@Repository` | Marks class as data access layer |
| `JpaRepository<T, ID>` | Provides built-in CRUD methods |

### Entity Layer
| Annotation | Purpose |
|-----------|---------|
| `@Entity` | Maps class to database table |
| `@Id` | Designates primary key field |
| `@GeneratedValue` | Configures auto-increment strategy |
| `@Column` | Configures column properties |

### Validation Annotations
| Annotation | Constraint |
|-----------|-----------|
| `@NotBlank` | Field must not be empty or whitespace |
| `@NotNull` | Field must not be null |
| `@Size` | String/Collection length validation |
| `@Min` | Numeric minimum value |
| `@Max` | Numeric maximum value |
| `@DecimalMin` | Decimal minimum value |
| `@DecimalMax` | Decimal maximum value |
| `@Pattern` | Regex pattern validation |
| `@Valid` | Triggers validation on nested objects |
| `@Email` | Validates email format |

### Lombok Annotations
| Annotation | Generates |
|-----------|-----------|
| `@Data` | Getters, setters, equals, hashCode, toString |
| `@NoArgsConstructor` | Default constructor |
| `@AllArgsConstructor` | Constructor with all fields |
| `@RequiredArgsConstructor` | Constructor for final fields |
| `@Getter` | Getter methods only |
| `@Setter` | Setter methods only |
| `@ToString` | toString() method |
| `@EqualsAndHashCode` | equals() and hashCode() methods |

##  Getting Started

### Prerequisites
- Java 17 or higher
- Maven 3.8+
- MariaDB 10.6 or higher
- Docker and Docker Compose (for containerized deployment)

### Installation

#### Option 1: Local Development (Without Docker)

1. Clone the repository:
```bash
git clone <repository-url>
cd productManagement
```

2. Configure database in `application.properties`:
```properties
spring.datasource.url=jdbc:mariadb://localhost:3306/product_db
spring.datasource.username=root
spring.datasource.password=your_password
spring.jpa.hibernate.ddl-auto=update
```

3. Build the project:
```bash
mvn clean package
```

4. Run the application:
```bash
mvn spring-boot:run
```

The API will be available at `http://localhost:8080/api/products`

#### Option 2: Docker Compose Deployment (Recommended)

1. Clone the repository:
```bash
git clone <repository-url>
cd productManagement
```

2. Build and start containers:
```bash
docker-compose up --build
```

This command will:
- Build the Docker image for the application
- Start MariaDB container with persistent storage
- Start the application container
- Automatically establish network connectivity between services
- Perform health checks for database availability

3. Access the API:
```
http://localhost:8083/api/products
```

4. Stop containers:
```bash
docker-compose down
```

5. Stop containers and remove volumes:
```bash
docker-compose down -v
```

### Docker Compose Environment Variables

The application automatically connects to MariaDB using these environment variables configured in `docker-compose.yml`:

- `SPRING_DATASOURCE_URL`: jdbc:mariadb://db:3306/product_db
- `SPRING_DATASOURCE_USERNAME`: root
- `SPRING_DATASOURCE_PASSWORD`: root

The MariaDB service is configured with:
- `MYSQL_ROOT_PASSWORD`: root
- `MYSQL_DATABASE`: product_db

##  Deployment

### Docker Build (Manual)

Build the image manually:
```bash
docker build -t product-management .
```

Run the container:
```bash
docker run -d \
  -p 8080:8080 \
  -e SPRING_DATASOURCE_URL=jdbc:mariadb://host.docker.internal:3306/product_db \
  -e SPRING_DATASOURCE_USERNAME=root \
  -e SPRING_DATASOURCE_PASSWORD=root \
  --name product-app \
  product-management
```

## Database Access (Docker Compose)

The MariaDB database runs inside a Docker container.
You can access it using:

docker exec -it mariadb mysql -u root -p

Data is persisted using Docker volumes, so it remains safe even after containers restart.


##  License

This project is licensed under the terms specified in the LICENSE file.

## Contributing

Contributions are welcome. Please ensure that your code follows the project's architecture and coding standards.

---

Built with ❤️ by Aman Deep